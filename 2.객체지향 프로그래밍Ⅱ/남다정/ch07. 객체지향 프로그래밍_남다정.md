## 1. 상속
기존 클래스를 재사용하여 새로운 클래스를 작성하는것  

- 장점: 재사용성을 높이고 중복 제거  

- 구현방법: extends키워드  

- 주의: 접근제어자가 private 또는 default인 멤버들은 상속을 받아도 자손클래스로부터의 접근이 제어된다.

- 자바는 단일 상속

- 모든 클래스의 조상 Object클래스  
-> Object클래스의 멤버를 상속받으므로 `toString()`이나 `equals(Object o)`와 같은 메서드를 따로 정의하지 않아도 사용 가능하다.

## 2. 오버라이딩
- 상속받은 메서드의 내용을 변경하는 것

- 자손클래스에서 오버라이딩 메서드 조건  
1. 선언부(이름/ 매개변수/ 반환타입)가 같아야한다.(자손클래스 타입으로 변경하는것은 가능)  
2. 접근제어자를 조상보다 좁은 범위로는 변경불가  
3. 예외는 조상보다 적은범위로 선언  
4. 인스턴스메서드를 static으로 또는 그 반대로는 변경 불가능  

- 오버로딩: 기존에 없는 새로운 메서드 정의

- super : 조상으로 상속받은 멤버 참조시 사용되는 참조변수  
조상클래스의 메서드 내용에 추가적으로 작업을 덧붙이는 경우 super를 사용하면 좋음  

- super() : 조상클래스의 생성자  
조상클래스의 멤버변수는 조상의 생성자에 의해 초기화해야한다.  

## 3. package와 import
- package: 물리적으로 .class파일을 포함하는 하나의 디렉토리

- import: 클래스이름을 지정해주는 대신 *를 사용한다고해서 실행시 성능상 차이는 없음  
-> 패키지에서 일치하는 클래스 이름을 찾아야한다는 수고를 더할뿐  
-> 그러나 *를 사용하면 어느클래스가 어느패키지에 속하는지 구별하기 어렵다는 단점이 있음  
-> *를 사용한다고해서 하위 패키지 클래스까지 포함하지않음  

- static import : static멤버를 호출할때 클래스이름 생략 가능


## 4. 제어자
- 접근제어자 : public/ protected/ default/ private
- 그외 : static/ final/ abstract/ native/ transient/ synchronized/ volatile/ strictfp

- static: 인스턴스멤버를 사용하지않는 메서드는 static메서드로 선언하는것이 속도가 더 빠르기때문에 static선언을 고려하도록한다.
- final : '변경이 될 수 없는'의 의미 -> 클래스에 final이 붙으면 다른클래스의 조상이 될 수 없음
- abstract: 클래스에 붙어서 클래스내에 추상메서드가 선언되었음을 의미하고, 메서드에 붙어서 선언부만 작성하고 수행내용은 구현하지않은 추상메서드임을 의미한다.  
추상메서드가 없는 클래스에도 abstract을 붙일수있는데(java.awt.event.WindowAdapter) 클래스의 인스턴스를 생성해봐야 의미가 없고, 해당클래스를 다른 클래스가 상속을 받아 일부메서드만 오버라이딩하여 사용하는 방식으로 사용할때 쓰임  
~~~java
public abstract class WindowAdapter
    implements WindowListener, WindowStateListener, WindowFocusListener
{
    protected WindowAdapter() {}
    public void windowOpened(WindowEvent e) {}
    public void windowClosing(WindowEvent e) {}
    public void windowClosed(WindowEvent e) {}
    ...
~~~

- 접근제어자
private : 같은 클래스내에서만 접근 가능  
default : 같은 패키지 내에서만 접근가능  
protected : 같은 패키지내 + 다른패키지의 자손클래스에서 접근가능(상속확장이 예상될때 private대신 사용)  
public : 접근제한없음  

- 접근제어자를 사용하는 이유 : 외부로부터 데이터 보호하기위해 + 외부에는 불필요한 내부적으로 사용되는 부분을 감추기위해

- 생성자가 private인 클래스는 다른 클래스의 조상이 될 수 없기때문에 클래스앞에 final을 추가하여 상속할 수 없는 클래스라는것을 알리는 것이 좋다. ex) Math클래스: 상수와 static메서드만으로 구성되어있어서 생성자접근제어자를 private으로 지정하고 final로 클래스를 선언  
- 메서드에 static과 abstract을 함께 사용할 수 없다(static은 몸통이 있는 메서드에만 사용)
- 클래스에 abstract와 final을 동시에 사용할 수 없다 (서로 의미 모순)
- abstract메서드의 접근 제어자가 private일 수 없다
- 메서드에 private과 final을 같이 사용할 필요는 없다(private은 오버라이딩 할수없기때문에 의미 충분)

## 5. 다형성
- 여러가지 형태를 가질 수 있는 능력  
- 조상클래스타입의 참조변수로 자손클래스의 인스턴스를 참조할수있음(반대는 불가)  
- 같은 타입의 인스턴스여도 참조변수의 타입에 따라 사용할수있는 멤버의 개수가 달라진다.  
- 업캐스팅: 자손 -> 조상 (형변환 생략가능)  vs 다운캐스팅: 자손 <- 조상 (형변환 생략불가)  
- 형변환을 수행하기 전 instanceof 연산자를 사용해서 참조변수가 참조하고있는 실제 인스턴스 타입을 확인하는것이 안전하다.(instanceof 결과값으로 true를 받으면 검사한 타입으로의 형변환이 가능하다)  
- 메서드의 경우 조상클래스의 메서드를 자손클래스에서 오버라이딩한경우에도 참조변수 타입에 관계없이 항상 실제 인스턴스의 오버라이딩된 메서드가 호출된다.  
- 멤버변수의 경우 참조변수의 타입에따라 달라진다.  

참고) Vector클래스는 동적으로 크기과 관리되는 객체 배열로서 내부적으로 Object타입의 배열을 가져 이 배열에 객체를 추가하거나 제거할수있다.

## 6. 추상클래스 abstract class
- abstract을 붙이기만하면 추상클래스가되고 클래스선언부의 키워드를 보고 추상메서드가 있으니 상속을 통해 구현해줘야한다는것을 쉽게 알 수 있다.  
- 추상메서드를 포함하고있지 않은 클래스에도 abstract를 붙여 추상클래스로 지정할수있고, 클래스의 인스턴스를 생성할수없게된다.
- 추상메서드 = 선언부만 작성하고 구현부는 작성하지않은 메서드
- 추상화: 클래스간 공통점을 찾아내 공통의 조상을 만드는 작업
- 구체화: 상속을 통해 클래스를 구현, 확장하는 작업

## 7. 인터페이스
~~~java
interface 인터페이스이름{
    public static final 타입 상수이름 = 값;
    public abstract 메서드이름(매개변수목록);
}
~~~  
- 모든 멤버변수는 public static final 이어야하며 생략가능하다.
- 모든 메서드는 public abstract이어야하며 생략할수있다. 단 static메서드와 디폴트 메서드는 예외(jdk1.8ver~)
- 다중상속이 가능
- 구현하는 인터페이스의 메서드 중 일부만 구현한다면 abstract 추상클래스로 선언해야한다.  
- 두개의 클래스로부터 상속받아야하는 상황의 경우 두 조상클래스중 비중이 높은쪽을 선택하여 상속받고, 다른한쪽은 클래스내부에 멤버로 포함시키는 방식으로 처리하거나 어느한쪽의 필요한 부분을 뽑아서 인터페이스로 만든다음 구현한다.  
- 리턴타입이 인터페이스라는것은 메서드가 해당 인터페이스를 구현한 클래스의 인스턴스를 반환한다는것을 의미한다.
- 인터페이스를 사용하면 서로 관계없는 클래스들에게 관계를 맺어줄수있다.(상속관계에 있지않고 같은 조상클래스를 가지고있지 않은 클래스들에게 하나의 인터페이스를 공통적으로 구현하게하여 관계를 맺어줄 수 있다.)
- 실제구현에 독립적인 프로그램을 작성하는것이 가능하다는 장점
- 메서드를 사용하는쪽에서는 사용하려는 메서드의 선언부만 알면 된다는점이 본질
- JDK1.8부터 디폴트메서드와 static메서드를 추가할수있다. (java.util.Collection인터페이스가 대표적)
- 인터페이스에 새로운 메서드를 추가해야하는 경우 디폴트메서드를 활용하여 해당인터페이스를 구현한 클래스를 변경하지 않아도 되도록 한다.  
- 디폴트메서드와 기존메서드의 충돌 : 인터페이스간 충돌->필요한쪽의 메서드와 같은내용으로 오버라이딩  
  조상메서드와의 충돌-> 조상클래스의 메서드가 상속


## 8. 내부클래스 inner class
- 내부클래스에서 외부클래스의 멤버들을 쉽게 접근할 수 있고,  
불필요한 클래스를 외부에 감춰 코드의 복잡성을 줄일수있다는 장점이 있다.  
- 내부클래스 중 스태틱클래스만 static 멤버를 가질수 있으며, final과 static이 동시에 붙은 변수는 상수이므로 모든 내부클래스에서 정의가 가능하다.  
- 익명클래스는 다른내부클래스와 달리 이름이 없고 클래스의 선언과 생성을 동시에 하여 오직 하나의 객체만을 생성할수있는 일회용 클래스이다.  
- 이름이 없기때문에 외부클래스명$숫자.class 형식으로 클래스 파일명이 결정된다.  